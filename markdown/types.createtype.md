<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@skunkteam/types](./types.md) &gt; [createType](./types.createtype.md)

## createType() function

Create a Type from the given type-implementation.

**Signature:**

```typescript
declare function createType<Impl extends BaseTypeImpl<any, any>>(
    impl: Impl,
    override?: Partial<Record<keyof BaseTypeImpl<any, any> | 'typeValidator' | 'typeParser', PropertyDescriptor>>,
): TypeImpl<Impl>;
```

## Parameters

| Parameter | Type                                                                                                                                                      | Description                                                |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| impl      | Impl                                                                                                                                                      | the type-implementation                                    |
| override  | Partial&lt;Record&lt;keyof [BaseTypeImpl](./types.basetypeimpl.md)<!-- -->&lt;any, any&gt; \| 'typeValidator' \| 'typeParser', PropertyDescriptor&gt;&gt; | _(Optional)_ override certain settings of the created type |

**Returns:**

[TypeImpl](./types.typeimpl.md)<!-- -->&lt;Impl&gt;

## Remarks

Type-implementations (i.e. subclasses of [BaseTypeImpl](./types.basetypeimpl.md)<!-- -->) provide all the necessary logic and information regarding validation and parsing, but they do not satisfy the `Type` contract yet. This method takes the `construct` method of the given type-impl and uses that function as the base of the Type. It then retrofits all properties of the given implementation onto that constructor function.
