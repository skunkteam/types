## API Report File for "@skunkteam/types"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function array<Element>(...args: [name: string, elementType: BaseTypeImpl<Element>] | [elementType: BaseTypeImpl<Element>]): TypeImpl<ArrayType<BaseTypeImpl<Element>, Element, Element[]>>;

// @public
export class ArrayType<ElementType extends BaseTypeImpl<Element>, Element, ResultType extends Element[]> extends BaseTypeImpl<ResultType> {
    constructor(elementType: ElementType, name?: string);
    // (undocumented)
    readonly basicType: 'array';
    // (undocumented)
    readonly elementType: ElementType;
    // (undocumented)
    readonly isDefaultName: boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
}

// @public
export abstract class BaseObjectLikeTypeImpl<ResultType> extends BaseTypeImpl<ResultType> {
    and<Other extends BaseObjectLikeTypeImpl<unknown>>(_other: Other): TypeImpl<IntersectionType<[this, Other]>>;
    // (undocumented)
    abstract readonly isDefaultName: boolean;
    // (undocumented)
    abstract readonly possibleDiscriminators: Array<{
        path: string[];
        values: LiteralValue[];
    }>;
    // (undocumented)
    abstract readonly props: Properties;
    // (undocumented)
    abstract readonly propsInfo: PropertiesInfo;
}

// @public
export abstract class BaseTypeImpl<ResultType> implements TypeLink<ResultType> {
    // @internal
    readonly [designType]: ResultType;
    andThen<Return, RestArgs extends unknown[]>(fn: (value: ResultType, ...restArgs: RestArgs) => Return): (input: unknown, ...restArgs: RestArgs) => Return;
    assert(input: unknown): asserts input is ResultType;
    get autoCast(): this;
    get autoCastAll(): this;
    protected autoCaster?(this: this, value: unknown): unknown;
    abstract readonly basicType: BasicType | 'mixed';
    check(input: unknown): ResultType;
    construct(input: unknown): ResultType;
    // (undocumented)
    protected createAutoCastAllType(): this;
    protected createResult(input: unknown, result: unknown, validatorResult: ValidationResult): Result<ResultType>;
    readonly enumerableLiteralDomain?: Iterable<LiteralValue>;
    extendWith<E>(factory: (type: this) => E): this & E;
    is(input: unknown): input is ResultType;
    abstract readonly name: string;
    or<Other extends BaseTypeImpl<unknown>>(_other: Other): TypeImpl<UnionType<[this, Other]>>;
    protected typeParser?(input: unknown, options: ValidationOptions): Result<unknown>;
    protected abstract typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
    validate(input: unknown, options: ValidationOptions): Result<ResultType>;
    withBrand<BrandName extends string>(name: BrandName): TypeImpl<BaseTypeImpl<Branded<ResultType, BrandName>>>;
    withConstraint<BrandName extends string>(name: BrandName, constraint: Validator<ResultType>): TypeImpl<BaseTypeImpl<Branded<ResultType, BrandName>>>;
    withName(name: string): this;
    withParser(...args: [name: string, newConstructor: (i: unknown) => unknown] | [newConstructor: (i: unknown) => unknown]): this;
    withValidation(validation: Validator<ResultType>): this;
}

// @public
export type BasicType = 'string' | 'number' | 'bigint' | 'boolean' | 'function' | 'object' | 'array' | 'symbol' | 'undefined' | 'null';

// @public
export const boolean: Type<boolean>;

// @public (undocumented)
export function booleanAutoCaster(input: unknown): boolean | typeof autoCastFailure;

// @public
export type Branded<T, BrandName extends string> = T extends WithBrands<infer Base, infer ExistingBrands> ? WithBrands<Base, BrandName | ExistingBrands> : WithBrands<T, BrandName>;

// @public
export function createType<Impl extends BaseTypeImpl<any>>(impl: Impl, override?: Partial<Record<keyof BaseTypeImpl<any> | 'typeValidator' | 'typeParser', PropertyDescriptor>>): TypeImpl<Impl>;

// @public
export interface Failure {
    details: OneOrMore<FailureDetails>;
    input: unknown;
    // (undocumented)
    ok: false;
    type: BaseTypeImpl<unknown>;
}

// @public (undocumented)
export type FailureDetails = {
    type: BaseTypeImpl<unknown>;
    input: unknown;
    parserInput?: unknown;
    path?: PropertyKey[];
    context?: string;
} & ({
    kind?: undefined;
} | {
    kind: 'missing property';
    property: string;
} | {
    kind: 'invalid key';
    property: string;
    failure: Failure;
} | {
    kind: 'invalid literal';
    expected: LiteralValue | LiteralValue[];
} | {
    kind: 'invalid basic type';
    expected: BasicType | BasicType[];
    expectedValue?: LiteralValue;
} | {
    kind: 'union';
    failures: Failure[];
} | {
    kind: 'custom message';
    message: string;
});

// @public (undocumented)
export type FullType<Props extends Properties> = TypeImpl<InterfaceType<Props, TypeOfProperties<Writable<Props>>>>;

// @public (undocumented)
export type int = The<typeof int>;

// @public (undocumented)
export const int: Type<Branded<number, 'int'>>;

// @public
export class InterfaceType<Props extends Properties, ResultType> extends BaseObjectLikeTypeImpl<ResultType> {
    constructor(props: Props, options: InterfaceTypeOptions);
    // (undocumented)
    readonly basicType: 'object';
    // (undocumented)
    readonly isDefaultName: boolean;
    readonly keys: (keyof Props)[];
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly options: InterfaceTypeOptions;
    // (undocumented)
    readonly possibleDiscriminators: {
        path: string[];
        values: LiteralValue[];
    }[];
    // (undocumented)
    readonly props: Props;
    // (undocumented)
    readonly propsInfo: PropertiesInfo<Props>;
    toPartial(name?: string): PartialType<Props>;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
    withOptional<PartialProps extends Properties>(...args: [props: PartialProps] | [name: string, props: PartialProps]): TypeImpl<IntersectionType<[this, PartialType<PartialProps>]>>;
}

// @public
export interface InterfaceTypeOptions {
    name?: string;
    partial?: boolean;
    strictMissingKeys?: boolean;
}

// @public
export function intersection<Types extends OneOrMore<BaseObjectLikeTypeImpl<unknown>>>(...args: [name: string, types: Types] | [types: Types]): TypeImpl<IntersectionType<Types>>;

// @public (undocumented)
export type IntersectionOfTypeTuple<Tuple extends TypeLink<unknown>[]> = IntersectionOfTypeUnion<Tuple[number]>;

// @public (undocumented)
export type IntersectionOfTypeUnion<Union extends TypeLink<unknown>> = (Union extends unknown ? (k: TypeOf<Union>) => void : never) extends (k: infer Intersection) => void ? MergeIntersection<Intersection> : never;

// @public
export class IntersectionType<Types extends OneOrMore<BaseObjectLikeTypeImpl<unknown>>> extends BaseObjectLikeTypeImpl<IntersectionOfTypeTuple<Types>> {
    constructor(types: Types, name?: string);
    // (undocumented)
    readonly basicType: 'object';
    // (undocumented)
    readonly combinedName: string;
    // (undocumented)
    readonly isDefaultName: boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly possibleDiscriminators: Array<{
        path: string[];
        values: LiteralValue[];
    }>;
    // (undocumented)
    readonly props: PropertiesOfTypeTuple<Types>;
    // (undocumented)
    readonly propsInfo: PropertiesInfo<PropertiesOfTypeTuple<Types>>;
    // (undocumented)
    readonly types: Types;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<IntersectionOfTypeTuple<Types>>;
}

// @public
export function isType(value: unknown): value is Type<unknown>;

// @public (undocumented)
export function keyof<T extends Record<string, unknown>>(...args: [name: string, keys: T] | [keys: T]): TypeImpl<KeyofType<T>>;

// @public
export class KeyofType<T extends Record<string, unknown>, ResultType extends keyof T = keyof T> extends BaseTypeImpl<ResultType> {
    constructor(keys: T, name?: string);
    // (undocumented)
    readonly basicType: 'string';
    // (undocumented)
    readonly enumerableLiteralDomain: string[];
    // (undocumented)
    readonly keys: T;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    translate(input: unknown): T[keyof T];
    // (undocumented)
    protected typeValidator(input: unknown): Result<ResultType>;
}

// @public (undocumented)
export function literal<T extends LiteralValue>(value: T): TypeImpl<LiteralType<T>>;

// @public
export class LiteralType<ResultType extends LiteralValue> extends BaseTypeImpl<ResultType> {
    constructor(value: ResultType);
    // (undocumented)
    readonly basicType: BasicType;
    // (undocumented)
    readonly enumerableLiteralDomain: ResultType[];
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected typeValidator(input: unknown): Result<ResultType>;
    // (undocumented)
    readonly value: ResultType;
}

// @public
export type LiteralValue = string | number | boolean | null | undefined | void;

// @public
export type MergeIntersection<T> = T extends Record<PropertyKey, unknown> ? {
    [P in keyof T]: MergeIntersection<T[P]>;
} : T;

// @public (undocumented)
export const nullType: TypeImpl<LiteralType<null>>;

// @public (undocumented)
export const number: Type<number>;

// @public (undocumented)
export function numberAutoCaster(input: unknown): number | typeof autoCastFailure;

// @public
export function object<Props extends Properties>(...args: [props: Props] | [name: string, props: Props] | [options: InterfaceTypeOptions, props: Props]): FullType<Props>;

// @public (undocumented)
export type ObjectUnionToIntersection<Union> = (Union extends unknown ? (k: Union) => void : never) extends (k: infer Intersection) => void ? MergeIntersection<Intersection> : never;

// @public
export type OneOrMore<T> = [T, ...T[]];

// @public
export function partial<Props extends Properties>(...args: [props: Props] | [name: string, props: Props]): PartialType<Props>;

// @public (undocumented)
export type PartialType<Props extends Properties> = TypeImpl<InterfaceType<Props, Partial<TypeOfProperties<Writable<Props>>>>>;

// @public (undocumented)
export function pattern<BrandName extends string>(name: BrandName, regExp: RegExp, customMessage?: string | false): Type<Branded<string, BrandName>>;

// @public
export type Properties = Record<string, Type<unknown>>;

// @public
export type PropertiesInfo<Props extends Properties = Properties> = {
    [Key in keyof Props]: {
        partial: boolean;
        type: Props[Key];
    };
};

// @public (undocumented)
export type PropertiesOfTypeTuple<Tuple extends BaseObjectLikeTypeImpl<unknown>[]> = ObjectUnionToIntersection<Tuple[number]['props']> & Properties;

// @public
export function record<KeyType extends number | string, ValueType>(...args: [name: string, keyType: BaseTypeImpl<KeyType>, valueType: BaseTypeImpl<ValueType>, strict?: boolean] | [keyType: BaseTypeImpl<KeyType>, valueType: BaseTypeImpl<ValueType>, strict?: boolean]): TypeImpl<RecordType<BaseTypeImpl<KeyType>, KeyType, BaseTypeImpl<ValueType>, ValueType>>;

// @public
export class RecordType<KeyTypeImpl extends BaseTypeImpl<KeyType>, KeyType extends number | string, ValueTypeImpl extends BaseTypeImpl<ValueType>, ValueType, ResultType extends Record<KeyType, ValueType> = Record<KeyType, ValueType>> extends BaseTypeImpl<ResultType> {
    constructor(keyType: KeyTypeImpl, valueType: ValueTypeImpl, name?: string, strict?: boolean);
    // (undocumented)
    readonly basicType: 'object';
    // (undocumented)
    readonly isDefaultName: boolean;
    // (undocumented)
    readonly keyType: KeyTypeImpl;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly strict: boolean;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
    // (undocumented)
    readonly valueType: ValueTypeImpl;
}

// @public
export function reportError(root: Omit<Failure, 'ok'>, level?: number): string;

// @public
export type Result<T> = Success<T> | Failure;

// @public
export class SimpleType<ResultType> extends BaseTypeImpl<ResultType> {
    // (undocumented)
    readonly basicType: BasicType | 'mixed';
    static create<ResultType>(name: string, basicType: BasicType | 'mixed', simpleValidator: (type: SimpleType<ResultType>, input: unknown, options: ValidationOptions) => ValidationResult, options?: Pick<BaseTypeImpl<ResultType>, 'enumerableLiteralDomain'> & {
        autoCaster: BaseTypeImpl<ResultType>['autoCaster'];
    }): Type<ResultType>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
}

// @public
export const string: Type<string>;

// @public
export interface Success<T> {
    // (undocumented)
    ok: true;
    value: T;
}

// @public
export type The<T> = TypeOf<T>;

// @public (undocumented)
export type Transposed<T extends Record<string, string>> = Record<T[keyof T], keyof T>;

// @public
export type Type<ResultType> = TypeImpl<BaseTypeImpl<ResultType>>;

// @public
export type TypeImpl<Impl extends BaseTypeImpl<any>> = Impl & {
    new (input: unknown): TypeOf<Impl>;
    (input: unknown): TypeOf<Impl>;
};

// @public
export interface TypeLink<AssociatedType> {
    readonly [designType]: AssociatedType;
}

// @public
export type TypeOf<T> = T extends TypeLink<infer Q> ? Q : never;

// @public
export type TypeOfProperties<T extends Properties> = {
    [P in keyof T]: TypeOf<T[P]>;
};

// @public
export type Unbranded<T> = T extends WithBrands<infer Base, any> ? Base : T;

// @public (undocumented)
export const undefinedType: TypeImpl<LiteralType<undefined>>;

// @public (undocumented)
export function union<Types extends OneOrMore<BaseTypeImpl<unknown>>>(...args: [name: string, types: Types] | [types: Types]): TypeImpl<UnionType<Types>>;

// @public
export class UnionType<Types extends OneOrMore<BaseTypeImpl<unknown>>, ResultType extends TypeOf<Types[number]> = TypeOf<Types[number]>> extends BaseObjectLikeTypeImpl<ResultType> {
    constructor(types: Types, name?: string);
    // (undocumented)
    readonly basicType: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function" | "array" | "null" | "mixed";
    // (undocumented)
    readonly collapsedTypes: Types;
    // (undocumented)
    readonly enumerableLiteralDomain: Set<LiteralValue> | undefined;
    // (undocumented)
    readonly isDefaultName: boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly possibleDiscriminators: {
        path: string[];
        values: LiteralValue[];
    }[];
    // (undocumented)
    readonly props: Record<string, TypeImpl<BaseTypeImpl<unknown>>>;
    // (undocumented)
    readonly propsInfo: PropertiesInfo<Record<string, TypeImpl<BaseTypeImpl<unknown>>>>;
    // (undocumented)
    readonly types: Types;
    // (undocumented)
    protected typeValidator(input: unknown, options: ValidationOptions): Result<ResultType>;
}

// @public
export const unknown: Type<unknown>;

// @public
export const unknownArray: Type<unknown[]>;

// @public
export const unknownRecord: Type<Record<string, unknown>>;

// @public
export class ValidationError extends Error implements Failure {
    // (undocumented)
    details: OneOrMore<FailureDetails>;
    static fromFailure(failure: Omit<Failure, 'ok'>): ValidationError;
    // (undocumented)
    input: unknown;
    // (undocumented)
    readonly name = "ValidationError";
    // (undocumented)
    readonly ok = false;
    static try<Return>({ type, input }: Pick<Failure, 'type' | 'input'>, fn: () => Return): Result<Return>;
    // (undocumented)
    type: BaseTypeImpl<unknown>;
}

// @public
export type ValidationMode = 'check' | 'construct';

// @public (undocumented)
export interface ValidationOptions {
    // (undocumented)
    mode: ValidationMode;
    // @internal (undocumented)
    visited?: Map<unknown, Map<unknown, Result<unknown>>>;
}

// @public
export type ValidationResult = boolean | string | string[] | FailureDetails | FailureDetails[];

// @public
export type Validator<ResultType> = (input: ResultType, options: ValidationOptions) => ValidationResult;

// @public (undocumented)
export function valueof<T extends Record<string, string>>(...args: [name: string, obj: T] | [obj: T]): TypeImpl<KeyofType<Transposed<T>>>;

// @public (undocumented)
export const voidType: TypeImpl<LiteralType<void>>;

// @public (undocumented)
export type WithBrands<T, BrandNames extends string> = T & {
    [brands]: {
        [P in BrandNames]: true;
    };
};

// @public
export type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};


```
